% [MATLAB API function]
% Centroid Decomposition, with the optional possibility of specifying truncation or usage of initial sign vectors
function [L_ret, R_ret, varargout] = centroid_decomposition(matrix, truncation, SV)% var = truncation(0), SV([])
    % input processing
    if nargin > 1
        truncation = varargin{1};
    else
        truncation = 0;
    end
    
    if nargin > 2
        SV = varargin{2};
    else
        SV = [];
    end
    
    if nargin > 3
        disp("[Centroid Decomposition] Warning: more than 3 arguments provided during the call. Anything beyond 3 is ignored.");
    end
    
    [n, m] = size(matrix);
    
    if truncation == 0
        truncation = m;
    end
    
    if truncation < 1 || truncation > m
        disp("[Centroid Decomposition] Error: invalid truncation parameter k=" + tostring(truncation));
        disp("[Centroid Decomposition] Aboritng decomposition");
        return; % returns not initialized
    end
    
    if size(SV, 1) == 0
        SV = default_SV(n, truncation);
    end
    
    if size(SV, 2) ~= truncation
        disp("[Centroid Decomposition] Error: provided list of Sign Vectors doesn't match in size with the truncation truncation parameter k=" + tostring(truncation));
        disp("[Centroid Decomposition] Aboritng decomposition");
        return; % returns not initialized
    end
    
    L = zeros(truncation, n);
    R = zeros(truncation, m);
    
    % main loop - goes up till the truncation param (maximum of which is the % of columns)
    for j = 1:truncation
        % calculate the sign vector
        Z = local_sign_vector(matrix, SV(:, j));
        
        % calculate the column of R by X^T * Z / ||X^T * Z||
        R_i = matrix' * Z;
        R_i = R_i / norm(R_i);
        R(j,:) = R_i;
        
        % calculate the column of L by X * R_i
        L_i = matrix * R_i;
        L(j,:) = L_i;
        
        % subtract the dimension generated by L_i and R_i from the original matrix
        matrix = matrix - L_i * R_i';
        
        % update the new sign vector in the array
        SV(:, j) = Z;
    end
    
    L_ret = L';
    R_ret = R';
    if nargout > 1
        varargout{1} = SV;
    end
end


% Algorithm: LSV (Local Sign Vector). Finds locally optimal sign vector Z, i.e.:
%   Z being locally optimal means: for all Z' sign vectors s.t. Z' is one sign flip away from Z at some index j,
%   we have that ||X^T * Z|| >= ||X^T * Z'||
function Z_ret = local_sign_vector(matrix, Z)
    [n, m] = size(matrix);
    
    Z = local_sign_vector_init(matrix, Z);
    
    % calculate initial product of X^T * Z with the current version of Z
    direction = matrix' * Z;
    % calculate initial value of ||X^T * Z||
    lastNorm = norm(direction) ^ 2 + eps;
    
    flipped = true;
    
    while flipped
        % we terminate the loop if during the last pass we didn't flip a single sign
        flipped = false;
        
        for i = 1:n
            signDouble = Z(i) * 2;
            gradFlip = 0.0;
            
            % calculate how ||X^T * Z|| would change if we would change the sign at position i
            % change to the values of D = X^T * Z is calculated as D_j_new = D_j - 2 * Z_i * M_ij for all j
            gradFlip = norm(direction - signDouble * matrix(i, :));
            
            % if it results in augmenting ||X^T * Z||
            % flip the sign and replace cached version of X^T * Z and its norm
            if gradFlip > lastNorm
                flipped = true;
                Z(i) = Z(i) * -1;
                lastNorm = gradFlip + eps;
                
                direction = direction - signDouble * matrix(i, :);
            end
        end
    end
    
    Z_ret = Z;
end


% Auxiliary function for LSV:
%   Z is initialized sequentiually where at each step we see which sign would give a larger increase to ||X^T * Z||
function Z_ret = local_sign_vector_init(matrix, Z)
    [n, m] = size(matrix);
    
    direction = matrix(1, :);
    
    for i = 2:n
        gradPlus = norm(direction + matrix(i, :));
        gradMinus = norm(direction - matrix(i, :));
        
        if gradMinus > gradPlus
            Z(i) = -1;
        end
        
        direction = direction + Z(i) * matrix(i, :);
    end
    
    Z_ret = Z;
end

%initialize sign vector array with default values
function SV = default_SV(n, k)
    % default sign vector is (1, 1, ..., 1)^T
    SV = ones(n, k);
end